package cve

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"path/filepath"
	"strings"
	"sync"

	"github.com/csye7125-su24-team06/webapp-cve-processor/internal/models"
	"github.com/zhyee/zipstream"
)


func Process(url string) {
	// Kafka Producer Go Routine
	kafka := NewKafkaProducer()
	var wg sync.WaitGroup
	cve := make(chan *[]byte)
	wg.Add(1)
	go func(cve chan *[]byte, kafka *KafkaProducer) {
		defer wg.Done()
		producer(cve, kafka)
	}(cve, &kafka)

	// Unzip the file
	zipStream, err := download(url)
	if err != nil {
		panic(fmt.Sprintf("Cve zip file download failed : %v", err))
	}
	if err := unzip(zipStream, cve); err != nil {
		log.Fatalf("Error unzipping file: %v", err)
	}

	// Wait for the go routine to finish
	wg.Wait()
}

func download(url string) (*io.ReadCloser, error) {
	fmt.Printf("Processing the zip file from %v\n", url)
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	return &resp.Body, nil
}

func unzip(zipStream *io.ReadCloser, handler chan *[]byte) error {
	zr := zipstream.NewReader(*zipStream)
	defer (*zipStream).Close()
	
	for {
		e, err := zr.GetNextEntry()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("unable to get next entry: %s", err)
		}
		if e.IsDir() || 
			filepath.Ext(e.Name) != ".json" || 
			strings.HasSuffix(e.Name, "delta.json") || 
			strings.HasSuffix(e.Name, "deltaLog.json") {
			continue
		}

		// Read the file from the zip archive.
		srcFile, err := e.Open()
		if err != nil {
			return err
		}
		data, err := io.ReadAll(srcFile)
		if err != nil {
			return err
		}

		// Send the data to the handler
		handler <- &data
	}

	return nil
}

func producer(cve chan *[]byte, kafka *KafkaProducer) {
	for elem := range cve {

		// Parse the data
		cve, err := parse(elem)
		if(err != nil) {
			panic(fmt.Sprintf("Cve deserialization failed %v", err))
		}

		// Send the message to the Kafka Topic
		if err := (*kafka).Produce(cve); err != nil {
			log.Printf("Error producing message: %v", err)
		}
    }

	// Close the channel.
	close(cve)
}

// CVE Json Data
type cveData struct {
	CveMetaData struct {
		Cve_id        string `json:"cveId"`
		DateUpdated   string `json:"dateUpdated"`
		DatePublished string `json:"datePublished"`
	}     `json:"cveMetadata"`
}

// Custom CVE Json Parser
func parse(data *[]byte) (*models.Cve, error) {
	var cveData cveData
	if err := json.Unmarshal(*data, &cveData); err != nil {
		return nil, err
	}

	// Build the CVE model
	cve := models.Cve{
		Cve_id:      cveData.CveMetaData.Cve_id,
		DateUpdated: parseDatePublished(cveData.CveMetaData.DateUpdated, cveData.CveMetaData.DatePublished),
		Data:        *data,
	}

	return &cve, nil
}
