package cve

import (
	"fmt"
	"io"
	"log"
	"path/filepath"
	"strings"
	"sync"

	"github.com/zhyee/zipstream"
)


func Process(url string, kafkaProducer *KafkaProducer) {
	// Kafka Producer Go Routine
	var wg sync.WaitGroup
	cve := make(chan *[]byte)
	wg.Add(1)
	go func(cve chan *[]byte, kafkaProducer *KafkaProducer) {
		defer wg.Done()
		producer(cve, kafkaProducer)
	}(cve, kafkaProducer)

	// Unzip the file
	zipStream, err := fetchZipStream(url)
	if err != nil {
		panic(fmt.Sprintf("Cve zip file retrieval failed : %v", err))
	}
	if err := unzip(zipStream, cve); err != nil {
		log.Fatalf("Error unzipping file: %v", err)
	}

	// Wait for the go routine to finish
	wg.Wait()
}

func unzip(zipStream *io.ReadCloser, handler chan *[]byte) error {
	zr := zipstream.NewReader(*zipStream)
	defer (*zipStream).Close()
	
	for {
		e, err := zr.GetNextEntry()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("unable to get next entry: %s", err)
		}
		if e.IsDir() || 
			filepath.Ext(e.Name) != ".json" || 
			strings.HasSuffix(e.Name, "delta.json") || 
			strings.HasSuffix(e.Name, "deltaLog.json") {
			continue
		}

		// Read the file from the zip archive.
		srcFile, err := e.Open()
		if err != nil {
			return err
		}
		data, err := io.ReadAll(srcFile)
		if err != nil {
			return err
		}

		// Send the data to the handler
		handler <- &data
	}

	// Close the channel.
	close(handler)
	return nil
}

func producer(cve chan *[]byte, kafka *KafkaProducer) {
	for elem := range cve {
		// Send the message to the Kafka Topic
		if err := (*kafka).Produce(elem); err != nil {
			log.Printf("Error producing message: %v", err)
		}
    }
}
