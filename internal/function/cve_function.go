package function

import (
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/csye7125-su24-team06/webapp-cve-processor/internal/constants"
	"github.com/csye7125-su24-team06/webapp-cve-processor/internal/helper"
	"github.com/csye7125-su24-team06/webapp-cve-processor/internal/models"
	"github.com/csye7125-su24-team06/webapp-cve-processor/internal/repository"
)

func ProcessCveMap(cveMap map[int][]string, sha1 string) { // TODO: PROGRESS TRACKING LOGIC
	var years []int
	for k := range cveMap {
		sort.Strings(cveMap[k])
		years = append(years, k)
	}

	sort.Ints(years)

	cveMap, years = trackProgress(sha1, years, cveMap)

	cveDocs := []models.Cve{}

	for _, year := range years {
		for i := range cveMap[year] {
			data, err := helper.ProcessJSONFile(cveMap[year][i])
			if err != nil {
				panic(fmt.Sprintf("Unmarshalling failure %v", err))
			}

			cve := models.Cve{
				Cve_id:      data.CveMetaData.Cve_id,
				DateUpdated: parseDatePublished(data.CveMetaData.DateUpdated, data.CveMetaData.DatePublished),
				Data:        data.RawData,
				Sha1:        sha1,
			}

			cveDocs = append(cveDocs, cve)

			if len(cveDocs) >= constants.BATCH_SIZE {
				repository.BulkInsertCve(cveDocs)
				cveDocs = nil
			}
		}
	}

	repository.BulkInsertCve(cveDocs)
	cveDocs = nil
}

func trackProgress(sha1 string, years []int, cveMap map[int][]string) (map[int][]string, []int) {
	cveDoc, tx := repository.FetchLatestBySHA1(sha1)

	if tx.RowsAffected == 0 {
		fmt.Println("No Existing Record Found. Starting Fresh Insertion")
		return cveMap, years
	}

	split := strings.Split(cveDoc.Cve_id, "-")
	year, _ := strconv.Atoi(split[1])

	years = years[helper.GetIndexOf(years, year):]
	cveMap[year] = cveMap[year][helper.GetIndexOf(cveMap[year], fmt.Sprintf("%v.json", cveDoc.Cve_id)):]

	fmt.Printf("Latest Existing Record Found for Year: %v with CVE_ID: %v. Continuing Insertion...\n", year, cveDoc.Cve_id)

	return cveMap, years
}

func parseDatePublished(updated string, published string) time.Time {

	var dateUpdated time.Time

	if len(updated) == 0 {
		updated = published
	}

	timeLayouts := []string{
		"2006-01-02T15:04:05",
		"2006-01-02T15:04:05Z",
		"2006-01-02T15:04:05.000Z",
	}

	var timeParseErr error
	for _, layout := range timeLayouts {
		dateUpdated, timeParseErr = time.Parse(layout, updated)
		if timeParseErr == nil {
			break
		}
	}

	if timeParseErr != nil {
		panic(fmt.Sprintf("Error Parsing Time : %v", timeParseErr))
	}

	dateUpdated = dateUpdated.UTC()
	return dateUpdated
}
