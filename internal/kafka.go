package cve

import (
	"context"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/segmentio/kafka-go"
	"github.com/segmentio/kafka-go/sasl/scram"
)

type KafkaProducer interface {
	InitTopic()
	Produce(cve *[]byte) error
	Close()
}

type kafkaProducer struct {
	conn  *kafka.Conn
	writer *kafka.Writer
	topic string
}

func NewKafkaProducer() KafkaProducer {
	network := GetEnvOrDefault("KAFKA_NETWORK", "tcp")
	topic := GetEnvOrDefault("KAFKA_TOPIC", "cve")
	brokersEnv := GetEnvOrDefault("KAFKA_BROKERS", "localhost:9092,localhost:9093,localhost:9094")
	brokers := strings.Split(brokersEnv, ",")
	primary := GetEnvOrDefault("KAFKA_PRIMARY", brokers[0])

	dialer := &kafka.Dialer{
		Timeout:       10 * time.Second,
		DualStack:     true,
	}

	username := GetEnvOrDefault("KAFKA_USERNAME", "")
	password := GetEnvOrDefault("KAFKA_PASSWORD", "")
	if username != "" || password != "" {
		auth, err := scram.Mechanism(scram.SHA512, username, password)
		if err != nil {
			log.Fatalf("Failed to create auth: %v", err)
		}
		dialer.SASLMechanism = auth
	}
	
	kafka.DefaultDialer = dialer
	conn, err := kafka.Dial(network, primary)
	if err != nil {
		log.Fatalf("Failed to connect to kafka: %v", err)
	}

	writer := kafka.Writer{
		Addr: kafka.TCP(brokers...), 
		Topic: topic,
	}

	if dialer.SASLMechanism != nil {
		transport := &kafka.Transport{
			SASL: dialer.SASLMechanism,
		}
		writer.Transport = transport
	}

	return &kafkaProducer{
		conn: conn,
		topic: topic,
		writer: &writer,
	}
}

func (k *kafkaProducer) InitTopic() {
	topic := GetEnvOrDefault("KAFKA_TOPIC", "cve")
	partitions, err1 := strconv.Atoi(GetEnvOrDefault("KAFKA_TOPIC_PARTITIONS", "3"))
	replication, err2 := strconv.Atoi(GetEnvOrDefault("KAFKA_TOPIC_REPLICATION", "3"))
	if err1 != nil || err2 != nil {
		log.Fatalf("Failed to parse env: %v, %v", err1, err2)
	}

	topicConfigs := []kafka.TopicConfig{
		{
			Topic:             topic,
			NumPartitions:     partitions,
			ReplicationFactor: replication,
		},
	}

	err := k.conn.CreateTopics(topicConfigs...)
	if err != nil {
		log.Fatalf("Failed to create topic: %v", err)
	}

	log.Printf("Created topic: %v", topic)
}

func (k *kafkaProducer) Produce(cve *[]byte) error {
	err := k.writer.WriteMessages(context.Background(), kafka.Message{
		Value: *cve,
	})
	return err
}

func (k *kafkaProducer) Close() {
	k.writer.Close()
	k.conn.Close()
}
