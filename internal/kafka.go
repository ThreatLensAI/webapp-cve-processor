package cve

import (
	"context"
	"log"
	"strconv"
	"strings"

	"github.com/twmb/franz-go/pkg/kadm"
	"github.com/twmb/franz-go/pkg/kgo"
)

type KafkaProducer interface {
	InitTopic()
	Produce(cve *[]byte) error
}

type kafkaProducer struct {
	client  *kgo.Client
	topic string
}

func NewKafkaProducer() KafkaProducer {
	brokers := GetEnvOrDefault("KAFKA_BROKER", "localhost:9092,localhost:9093,localhost:9094")
	topic := GetEnvOrDefault("KAFKA_TOPIC", "cve")

	client, err := kgo.NewClient(kgo.SeedBrokers(strings.Split(brokers, ",")...))
	
	if err != nil {
		log.Fatalf("Failed to connect to kafka: %v", err)
	}
	return &kafkaProducer{
		client: client,
		topic: topic,
	}
}

func (k *kafkaProducer) InitTopic() {
	topic := GetEnvOrDefault("KAFKA_TOPIC", "cve")
	partitions, err1 := strconv.Atoi(GetEnvOrDefault("KAFKA_PARTITIONS", "-1"))
	replication, err2 := strconv.Atoi(GetEnvOrDefault("KAFKA_REPLICATION", "-1"))
	if err1 != nil || err2 != nil {
		log.Fatalf("Failed to parse env: %v, %v", err1, err2)
	}
	adminClient := kadm.NewClient(k.client)
	res, err := adminClient.ListTopics(context.Background(), topic)
	if err != nil {
		log.Fatalf("Failed to list topics: %v", err)
	}

	if len(res) > 0 {
		log.Printf("Topic %s already exists", topic)
		return
	}

	config := make(map[string]*string)
	createRes, err := adminClient.CreateTopic(context.Background(), int32(partitions), int16(replication), config, topic)
	if err != nil {
		log.Fatalf("Failed to create topic: %v", err)
	}

	log.Printf("Created topic: %v with id: %v", topic, createRes.ID)
}

func (k *kafkaProducer) Produce(cve *[]byte) error {
	res := k.client.ProduceSync(context.Background(), &kgo.Record{
		Topic: k.topic,
		Value: *cve,
	})
	return res.FirstErr()
}
